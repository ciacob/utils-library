package ro.ciacob.utils {
import com.adobe.crypto.MD5;

import flash.display.Screen;
import flash.geom.Point;
import flash.geom.Rectangle;

public class ScreenUtils {

    public static const SCREEN_TOP:String = 'screenTop';
    public static const SCREEN_RIGHT:String = 'screenRight';
    public static const SCREEN_BOTTOM:String = 'screenBottom';
    public static const SCREEN_LEFT:String = 'screenLeft';
    public static const NOT_FOUND:String = 'screenNotFound';


    public static function adjustSystemTrayBounds(bounds:Rectangle, keepInVisibleArea:Boolean):Rectangle {
        switch (taskBarPosition) {
            case SCREEN_TOP:
                //UPPER RIGHT
                bounds.x -= bounds.width;
                break;
            case SCREEN_RIGHT:
            case SCREEN_BOTTOM:
                // LOWER RIGHT
                bounds.x -= bounds.width;
                bounds.y -= bounds.height;
                break;
            case SCREEN_LEFT:
                // LOWER LEFT
                bounds.y -= bounds.height;
                break;
        }
        if (keepInVisibleArea) {
            var screenVisible:Rectangle = Screen.mainScreen.visibleBounds;
            if (!screenVisible.containsRect(bounds)) {
                if (bounds.x < screenVisible.x) {
                    bounds.x = screenVisible.x;
                }
                if (bounds.y < screenVisible.y) {
                    bounds.y = screenVisible.y;
                }
                if (bounds.right > screenVisible.right) {
                    bounds.x -= (bounds.right - screenVisible.right);
                }
                if (bounds.bottom > screenVisible.bottom) {
                    bounds.y -= (bounds.bottom - screenVisible.bottom);
                }
            }
        }
        return bounds;
    }

    public static function get taskBarPosition():String {
        var screenFull:Rectangle = Screen.mainScreen.bounds;
        var screenVisible:Rectangle = Screen.mainScreen.visibleBounds;
        if (screenVisible.top > screenFull.top) {
            return SCREEN_TOP;
        }
        if (screenVisible.right < screenFull.right) {
            return SCREEN_RIGHT;
        }
        if (screenVisible.bottom < screenFull.bottom) {
            return SCREEN_BOTTOM;
        }
        if (screenVisible.left > screenFull.left) {
            return SCREEN_LEFT;
        }
        return NOT_FOUND;
    }

    public static function getScreenForPoint(point:Point):Screen {
        var screen:Screen = null;
        var screenBounds:Rectangle = null;
        var screens:Array = Screen.screens;
        for each (screen in screens) {
            screenBounds = screen.bounds;
            if (screenBounds.contains(point.x, point.y)) {
                return screen;
            }
        }
        return null;
    }

    public static function get mainScreenAvailableHeight():Number {
        return Screen.mainScreen.visibleBounds.height;
    }

    /**
     * Retrieves information about all available screens connected to the system.
     *
     * This function iterates over all screens detected by the AIR runtime and gathers
     * essential properties such as screen dimensions, position, and whether it's the
     * main display.
     *
     * Each screen's information is hashed to generate a unique identifier (UID) which
     * aids in distinguishing between screens, especially in multi-monitor setups.
     *
     * @return An array of objects, each representing a screen. The objects contain the
     * following keys:
     * - uid: A unique identifier for the screen, generated by hashing screen properties.
     * - isMain: A Boolean indicating whether the screen is the primary display.
     * - x: The x-coordinate of the screen's available area, accounting for system UI elements.
     * - y: The y-coordinate of the screen's available area.
     * - width: The width of the screen's available area.
     * - height: The height of the screen's available area.
     * - toString: A function that returns a string representation of the screen, including
     *   its dimensions, position, and UID.
     *
     *   Notes:
     *   (1) if not empty, the returned Array is guaranteed to have the main display at index `0`.
     *   (2) minimum available width and minimum available height, across all screens, and after compensating for
     *   any scale factors found, will be retained as "minW" and "minH", which will be available as statical properties
     *   on the returned Array.
     */
    public static function getScreensInfo():Array {
        var mainScreen:Screen = Screen.mainScreen;
        var mainScreenBounds:Rectangle = mainScreen.bounds;
        var screens:Array = Screen.screens;
        var screensInfo:Array = [];
        var minW:Number = NaN;
        var minH:Number = NaN;
        for each (var screen:Screen in screens) {

            // There is a bug in the runtime: (screen === Screen.mainScreen) returns `false` .
            var isMainScreen:Boolean = (screen.bounds.equals(mainScreenBounds));
            var bounds:Rectangle = screen.visibleBounds;
            var x:Number = bounds.x;
            var y:Number = bounds.y;
            var w:Number = bounds.width;
            var h:Number = bounds.height;
            var s : Number = screen.contentsScaleFactor;
            var uid:String = MD5.hash((isMainScreen ? 'm' : '') + 's' + s + 'w' + w + 'h' + h + 'x' + x + 'y' + y)
                    .substr(-7);
            if (s != 1) {
                x = Math.floor (x/s);
                y = Math.floor (y/s);
                w = Math.floor (w/s);
                h = Math.floor (h/s);
            }
            if (isNaN(minW) || w < minW) {
                minW = w;
            }
            if (isNaN(minH) || h < minH) {
                minH = h;
            }
            var info:Object = {
                "uid": uid,
                "isMain": isMainScreen,
                "x": x,
                "y": y,
                "width": w,
                "height": h,
                "scale": s,
                "toString": function ():String {
                    return (
                        (this.isMain ? '[Main] ' : '') +
                        this.width + 'x' + this.height + '@ ' +
                        this.x + ':' + this.y +
                        ' [' + this.scale + ':1]' +
                        " | " + this.uid
                    );
                }
            };
            if (isMainScreen) {
                screensInfo.unshift(info);
            } else {
                screensInfo.push(info);
            }
        }
        if (!isNaN(minW)) {
            screensInfo.minW = minW;
        }
        if (!isNaN(minH)) {
            screensInfo.minH = minH;
        }
        return screensInfo;
    }
}
}
